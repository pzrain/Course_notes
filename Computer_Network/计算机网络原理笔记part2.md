### Chapter07-1 传输层基础

#### 7.1传输服务需求与设计

**主机到主机**$\rightarrow$**进程到进程**

传输层需求：

1. 明确传输的数据属于哪个应用，通过**端口号**来区分一个主机上的不同进程
2. 向上层提供更好的服务，消除网络层的不可靠性
3. 海量终端协同实现公平性

传输层服务：

* **发送端复用**：传输层从多个应用收集数据，交给网络层发送
* **接收端分用**：传输层将从网络层收到的数据，交付给正确的应用

#### 7.2传输协议的要素

* **寻址**

  1. 传输服务访问点**TSAP**：传输层上的“端点”
  2. 网络服务访问点**NSAP**：网络层上的“端点”，例如IP地址

  > 例如，应用进程（包括客户和服务器）可以将自己关联到一个本地TSAP上，以便与一个远程TSAP建立连接。这些连接建立在每台主机的NSAP之上。

* **建立连接**：TCP三次握手，SYN， SYN、ACK， ACK

* **释放连接**

  TCP采用**对称释放**，各方单独DISCONNECT，**停止发送但继续接受**，双方均DISCONNECT后释放连接。一共四次挥手，FIN， ACK， FIN， ACK。

  主机1发送DR并启动计时器，主机2收到DR后也发送DR并启动定时器。主机1超时后重新发送DR，收到DR后释放连接并发送ACK。主机2收到ACK后也释放连接。同时，如果超时达到N次，也会释放连接。

* **差错控制与流量控制**

  传输层的**时延带宽积较大**，需要使用较大的滑动窗口。同时，为防止死锁，需要周期性发送控制报文。

* **多路复用**：

  1. 向上多路复用：多个传输连接使用同一网络连接
  2. 向下多路复用：一个传输连接使用多个网络连接

#### 7.3拥塞控制

拥塞包括**网络中的交通阻塞**，以及**路由器/交换机具有用于争用的内部缓冲区**。

网络的重要任务就是将其容量（带宽）公平分配给大量发送方。网络层见证拥塞，而传输层导致拥塞（只有传输层可以减少提供的负载）。

**最大-最小公平**：

如果分配给一个流的带宽在不减少分配给另一个流带宽的前提下无法得到进一步增长，那么就不给这个流更多带宽。也就是说，增加一个流的带宽只会让不太富裕的那些流的情况变得更糟。

#### 7.4UDP

UDP用户数据包只能提供不可靠的交付，只在IP的数据报服务质上增加了很少一点功能，支持复用和分用，以及差错检测。

* UDP是无连接的：发送数据之前不需要建立连接

* UDP不保证可靠交付，因此主机不需要维持复杂的连接状态表

* UDP是面向报文的，也即UDP一次交付一个完整的报文

  因此应用程序必须选择合适大小的报文，报文太长IP层在传输时会进行分片；报文太短会使IP数据报的首部的相对长度太大，这也降低了IP层的效率。

* UDP没有拥塞控制，因此**网络出现的拥塞不会使得源主机的发送速率降低**

  > 这一点对于一些实时应用很重要，RTP（RFC3550）就广泛应用于多媒体应用程序

* UDP支持一对一、一对多、多对一和多对多的交互通信

* UDP的首部开销小，只有8个字节（源端口（2）+目的端口（2）+长度（2）+校验和（2））

> 数据流五元组：源IP地址、目的IP地址、源端口、目的端口、协议号

> A port is a virtual point where network connections start and end. Ports are software-based and managed by a computer's operating system. Each port is associated with a specific process or service. 

#### 7.5TCP

传输控制协议TCP：面向连接的、可靠的、端到端的、基于字节流的传输协议。

> 基于字节流：接收方应用程序收到的字节流和发送方应用程序发出的字节流完全一样。TCP把应用程序交下来的数据看成仅仅是一连串无结构的字节流，并对连续的字节流进行分段，形成TCP报文段。

<img src="TL.png">

TCP连接管理有限自动机：

<img src="tcp.png">

早期的TCP使用固定大小的滑动窗口（例如8个数据报），由于“低能窗口问题”而禁止1字节窗口更新段。

**TCP拥塞控制**：根据网络状态调整窗口大小，发送速率与网络带宽匹配。
$$
发送窗口=\min(拥塞窗口，流控窗口)
$$
一般**拥塞窗口大小=时延带宽积**，当发送的数据量达到拥塞窗口大小时，网络就会处于满负荷的拥挤状态。

**滑动窗口的ACK时钟**：避免突发，使得流量尽量平稳。当发送端向网络中注入大量段时，段会被缓冲并在慢速链接上分散。ACK保持确定的速率传回发送端，发送端用该速率作为新段的发送速率，这样在瓶颈链路的发送就不会产生队列。

**TCP计时器管理**：超时值RTO
$$
SRTT_{新}=\alpha SRTT_{老}+(1-\alpha)R\\
RTTVAR=\beta RTTVAR+(1-\beta)|SRTT-R|\\
RTO=SRTT+4\times RTTVAR
$$
**AIMD法则**：主机间不进行沟通，由路由器向各主机提供反馈，随时间产生每个主机速率的**锯齿模式**，采用**加性增**和**乘性减**，最终会收敛于高效且公平的分配。

**TCP Tahoe/Reno**基于AIMD来实现拥塞控制。使用**丢包**作为网络反馈信号，通过调整**拥塞窗口cwnd**来实现AIMD。拥塞控制分为两个阶段：

* 拥塞窗口cwnd**慢启动过程**

  拥塞窗口的大小对RTT呈**指数增长**（即每收到一个未超时确认，cwnd*=2），cwnd初始值为1个段。

* cwnd**线性增加过程**

  每过一个RTT，cwnd++。

慢启动阈值初始为流量控制窗口大小，发生确认超时后，**阈值降为*当前拥塞窗口*的一半**，然后重新启动。一旦**慢启动超过阈值**，TCP就从慢启动切换到线性增加状态。TCP Reno采用快速恢复，当收到三个重复确认后，**窗口降到阈值而非降为1**。

TCP后续增加了选择确认SACK，可以列出3个已收到的字节范围。丢包前，路由器在分组中设置ECN拥塞信号，接收端设置ECN Echo标志位，发送端减速。

**无线问题**：

1. TCP连接丢失率：1%，极限10%，发生传输错误时应**减速重传**。
2. 802.11**正常**丢失率：10%，发生传输错误时应**加速重传**。



### Chapter07-2传输层进阶

#### 7.6拥塞控制的发展

* **TCP-BIC:Binary Increase Congestion**

  BIC算法对满载窗口进行**二分查找**，在ACK时钟的驱动下，将拥塞窗口大小置为$(W_1+W_2)/2$（$W_1$为发生丢包时的窗口上限，$W_2$为乘性减小的窗口下限）。

  如窗口再次达到$W_1$而没有丢包，说明满载窗口大于$W_1$，则以**逼近$W_1$的镜像过程**增大拥塞窗口。

  但是，由于BIC以ACK时钟驱动拥塞窗口的更新，**RTT**较短的连接会更快到达满载窗口，占据更多的带宽，产生不公平性问题。

* **TCP-CUBIC**

  CUBIC将BIC算法**连续化**，用**三次函数拟合BIC算法曲线**。

  CUBIC不再根据RTT间隔来确定调整窗口的时机，**拥塞窗口成为距上次丢包时间t的函数**。CUBIC已实现在Linux2.6.18中。

* **拥塞与瓶颈链路带宽**

  BtlBw：不会引起路由器缓存排队的最大发送速率

  RTptop：**往返**时间

  **带宽时延积**：**BDP=BtlBw\*RTprop**

  > The TCP Window is a buffer that determines how much data can be  transferred **before the server stops and waits for acknowledgements of  received packets**. So BDP is the amount of data that left the sender **before the first acknowledgement was received by the sender**.

* **BBR(Google)**

  BBR试图测量出BtlBw以及RTT，来估算当前的BDP。测量最低延迟时，保证链路队列为空，网络中分组越少越好，cwnd较小；测量最大带宽时，就要把瓶颈链路填满，此时buffer中存在排队分组，延迟较高

  **BDP检测**：进入稳定状态后，先在一个RTT内增加发送速率，探测**最大带宽**；接着减小发送速率，排空前一个RTT多发的包；后续6个周期使用更新后的估计带宽发送。每过10s，进入RTprop检测阶段，在占全过程2%的时间内，cwnd固定为4个包。**以测得的RTprop作为基准，用以判断带宽检测阶段瓶颈链路中是否发生排队**。

#### 7.7新型传输层协议QUIC

QUIC实现在用户态中，底层基于UDP实现，拥塞控制是模块化的，可以方便地使用各种TCP拥塞控制算法，如Cubic等。

* QUIC的**数据随密钥同时发送**，建立连接仅需一个RTT。
* TCP的重传包使用和原包相同的序号，容易产生**重传歧义**；QUIC的包序号单调递增，ACK没有歧义从而可以更准确的测量RTT。
* 在IP地址/端口切换时无需重新建立连接。当IP地址/端口发生变化时，TCP连接会断开；而QUIC使用**Connection ID**来表示每个连接，IP地址或端口的变化不影响对原有连接的识别。
* QUIC连接中，建立互相独立的多个**子流**，某子流数据报丢失不影响其他子流数据交付。
* 整个QUIC包被加密传输，避免被中间设备识别和修改
* QUIC在**用户态**实现，与操作系统解耦，从而能和应用一同快速迭代
* 版本协商机制易于更新迭代

#### 7.8多路径传输协议MPTCP

其可将单一数据流切分为若干子流，同时利用多条路径进行传输。

MPTCP位于套接字和TCP之间，应用程序通过套接字调用MPTCP，MPTCP向应用程序提供单条连接的抽象，因而**对应用层透明**。并且，MPTCP兼容并扩展了TCP协议，TCP基本头不变，只定义了新的选项，从而对网络层也是透明的。

* **初始化MPTCP连接**

  主机A发出SYN报文段，其中启用了`MP_CAPBLE`字段，用以询问主机B是否支持MPTCP；若主机B支持MPTCP，则响应SYN/ACK报文段，其中启用了MP_CAPBLE字段并附上自己的密钥。主机A收到后向主机B发送ACK报文段，并附上自己和主机B的密钥，至此MPTCP的连接初始化完成。

* **MPTCP路径管理和关闭连接**

  * **新增路径**：主机A发送启用了`ADD_ADDR`字段的报文段，包含新的IP地址/端口对和对应的IP地址编号；主机B验证无误后记录路径信息，向主机A发送ECHO响应报文段。

  * **删除路径**：主机A发送`REMOVE_ADDR`报文，指定要删除的地址编号

  * **关闭单个子流**：与关闭常规TCP连接一致

  * **关闭所有子流**：主机A发送启用了`MP_FASTCLOSE`字段的报文段，其中附加了主机B的密钥用以身份验证。主机B收到后，选择恰当时机关闭所有连接，并向主机A发出确认。

  * **附加子流到MPTCP连接上**

    启用新的子流（A2$\rightarrow$B2），使用`MP_JOIN`，附加到已存在的MPTCP连接。主机A根据`Key-B`生成主机B的令牌（`Token-B`），该令牌指定当前子流需要附加到哪个MPTCP连接上，并将当前子流的地址编号（`A2-ID`）添加到SYN报文段中。主机B根据前面`MP_CAPBLE`字段交换的密钥等信息，和当前子流的地址编号`B2-ID`一同写入`SYN/ACK`报文段。

* **MPTCP的数据调度**

  在多路径传输中，发送端将属于同一个数据流的数据报调度到不同路径上传输，由于不同路径的差异，这些数据包往往无法按照发送顺序到达接收端。乱序到达的数据报需**暂存**在接受缓存中，直到接受缓存中的数据报能够按序交付给上层应用，**这既影响了数据传输的实时性，又影响了网络的吞吐量**。

  MPTCP根据拥塞窗口大小以及路径延迟，将数据**按比例**分配给各个子流，尽力保证数据包按序到达接收端，降低数据乱序到达对网络性能产生的不利影响。

#### 7.9数据中心网络传输协议

设计原则：**容忍高突发流量**、**低时延**、**高吞吐**

* **DC（Data Center）TCP**

  根据交换机队列的瞬时长度标记**ECN**（Explicit Congestion Notification）。当队列长度超过K时，给之后的包标记ECN。

  接收端，当**被标记的包首次出现或不再出现时**，立即发送ACK，否则采取Delay ACK的策略。

  发送端，每隔1个RTT根据拥塞程度**精细调整发送窗口**：$cwnd\leftarrow cwnd\times(1-\alpha/2)$，$\alpha$为拥塞信号的“拥塞程度”

  DCTCP能将队列长度稳定地维持在低水平，适用于**高带宽低时延**的数据中心网络。

* **RDMA（Remote Direct Memory）远程直接内存访问**

  数据传输不经过Linux TCP/IP协议栈