---
header: Assembler Language Programming
footer: Page ${pageNo} of ${totalPages}
author: Panzirui
---

---

[TOC]

## 8.异常控制流

### 8.1异常

**异常**是控制流中的**突变**，用来响应处理器状态中的某些变化。状态变化称为事件，其可能和当前指令的执行直接相关，也可能没有关系。任何情况下，当有事件发生时，处理器会通过**异常表**进行一个间接过程调用，到一个专门设计用来处理这类事件的**操作系统子程序**，也就是**异常处理程序**。异常处理程序完成处理后，会根据引起异常的事件的类型发生以下几种情况中的一种：

1. 处理程序讲控制返回给当前指令$\bold{I_{curr}}$，即当事件发生时正在执行的指令。
2. 处理程序讲控制返回给$\bold{I_{next}}$，即如果没有发生异常将会执行的下一条指令。
3. 处理程序**终止**被中断的内容。

系统中可能的每种类型的异常都分配了一个**唯一**的非负整数的**异常号**，其中部分号码是由处理器的设计者分配的，如*被零除*、*缺页*、*断点*，部分号码是由操作系统**内核**（即操作系统常驻内存的部分）的设计者分配的，如*系统调用*、*来自外部的**I/O**信号*。系统启动时，操作系统即分配和初始化**异常表**，使得表目k包含**异常k的处理程序地址**。异常表的起始地址放在一个叫做**异常表基址寄存器**的特殊CPU寄存器里。

> 异常与过程调用的区别：
>
> * 异常处理程序运行在**内核模式**下，这也意味着所有的项目、处理状态等会被压入**内核栈**中。
> * 过程调用时，跳转到处理程序之前，处理器会将返回地址压入栈中。但是异常处理未必返回到原来地址。

处理程序处理完事件后，会执行一条特殊的“**从中断返回**”的指令，可选地返回到被中断的程序，并将适当的状态弹回处理器的控制和数据寄存器中。特别地，如果异常中断的时一个用户程序，就将状态恢复为**用户模式**。

异常可以分为四类：**中断**、**陷阱**、**故障**和**终止**。陷阱、故障和终止是**同步**发生的，是执行当前指令的结果，这类指令被叫做**故障指令**。各自属性详见下表：

| 类别 | 原因              | 异步/同步 | 返回行为             |
| ---- | ----------------- | --------- | -------------------- |
| 中断 | 来自I/O设备的信号 | 异步      | 总是返回到下一条指令 |
| 陷阱 | __有意的异常__    | 同步      | 总是返回到下一条指令 |
| 故障 | 潜在可恢复的错误  | 同步      | 可能返回到当前指令   |
| 终止 | 不可恢复的错误    | 同步      | 不会返回             |

> * 陷阱**最重要的用途是在用户程序和内核之间提供一个像过程一样的接口，叫做**系统调用**，比如读文件（read）、创建一个新的进程（fork）。系统调用运行在**内核模式**中。
> * 一个经典的故障就是**缺页异常**。如果处理程序能够修复故障，那么它就将控制返回到引起故障的指令，从而重新执行它；否则程序返回到内核中的*abort*例程，进而终止应用程序。另外，许多原因都会导致不为人知的**一般保护故障**，通常是因为一个程序引用了一个未定义的虚拟内存区域，或者因为程序试图写一个只读的文本段。*linux shell*通常会把这种一般保护故障报告为“**段故障**”（Segmentation Fault）。

### 8.2进程

#### 8.2.1流

进程的经典定义就是**一个执行中程序的实例**。系统中每个程序都运行在某个**进程的上下文**中。**上下文**是由程序正确运行所需的状态组成的，这个状态包括存放在内存中的程序的**代码**和**数据**，它的**栈**、**通用目的寄存器的内容**、**程序计数器**、**环境变量**和**打开文件描述符的集合**。上下文就是内核重新启动一个被抢占的进程所需的状态。这一过程是由内核叫做**调度器**的代码处理的。

当内核选择一个新的进程运行时，就说内核**调度**了这个进程，其抢占当前进程，并使用一种称为**上下文切换**的机制来将控制转移到新的进程。具体而言，上下文切换会保存当前进程的上下文，恢复某个先前被抢占的进程被保存的上下文并将控制传递给这个新回复的进程。

程序运行时，PC（程序计数器）的值在不断变化，**PC值的序列**被称为**逻辑控制流**。一个逻辑流的执行在时间上与另一个流重叠（从开始到结束的时间片有重叠），被称为**并发流**。多个流并发地执行的一般现象被称为**并发**。一个进程和其他进行轮流运行的概念被称为**多任务**。一个进程执行它的控制流的一部分的每一时间段被称为**时间片**。如果两个流**并发地**运行在不同地处理器核或计算机上，就称它们为**并行流**。

#### 8.2.2私有地址空间

进程为每个程序提供一种*假象*，即好像它单独地使用系统地址空间。一般而言，和某个进程的私有地址空间相关联的内存字节是不能被其他进程读或者写的，因此从这个意义上这个地址空间是私有的。每个这样的空间都有着相同的**通用结构**，其中x86-64 Linux进程地址空间的组织结构如下：

<img src="D:\study\Sophomore\First_Semester\Assembler_Language_Programming\private_address_space.jpg" height=400>

处理器通常是用某个控制寄存器中的一个**模式位**来限制一个应用可以执行的指令以及它可以访问的地址空间范围。当设置了模式位时，进程就运行在**内核模式**中，其可以执行指令集中的任何指令，并且可以访问系统中的任何内存位置。反之，没有设置模式位时，进程就运行在**用户模式**中，其不允许执行**特权指令**，比如停止处理器、改变模式位，也不允许用户模式中的进程直接引用地址空间中内核区的代码和数据，而只能通过系统调用接口来间接访问。**进程从用户模式变为内核模式的唯一方法就是通过注入中断、故障或者陷入系统调用这样的异常**。

### 8.3进程过程

#### 8.3.1获取进程ID

每个进程都有一个唯一的正数进程ID（PID）。

```C++
#include <unistd.h>
pid_t getpid(void); // 返回调用进程pid
pid_t getppid(void); // 返回调用进程的父进程pid
```

#### 8.3.2创建和终止进程

1. `exit(int status)`：以*status*退出状态来终止进程

2. `fork()`：父进程调用`fork`来创建一个新的运行的**子进程**。

   注意，`fork()`调用一次，但却分别在父进程和子进程中**各返回一次**，前者中返回值等于子进程的PID，后者中返回值为0。**子进程得到与父进程用户级虚拟地址空间相同的（但是==独立的==）一份副本，包括代码和数据点、堆、共享库以及用户栈，子进程还获得与父进程任何打开文件描述符相同的副本**。此外，父进程和子进程是并发运行的独立进程，内核能够以**任意方式**交替执行它们的逻辑流中的指令。一般而言，我们**绝不能**对不同进程中指令的交替执行顺序做任何假设。

   > 对于运行在单处理器上的程序，对应进程图中所有顶点的**拓扑排序**表示程序中语句的一个可行的全序排列。

#### 8.4.3回收子进程

当某个进程由于某种原因终止时，内核并不是立即将它从系统中清除，相反，进程保持在一种已终止的状态中（被称为**僵死进程**），直到被它的父进程**回收**。当父进程回收已终止的子进程时，内核将子进程的退出状态传递给父进程，然后抛弃已终止的子进程，这时该进程才不存在了。

> 如果一个父进程终止了，内核会安排*init*进程成为它的孤儿进程的*养父*，*init*进程的pid为1，其不会终止。而即使僵死程序没有运行，它们依然消耗系统的内存资源。

一个进程可以通过调用`waitpid`函数来等待它的子进程终止或者停止：

```C++
#include <sys/wait.h>
#include <sys/types.h>
pid_t waitpid(pid_t pid, int *statussp, int options=0);
// 成功时，返回子进程PID，如果options=WHNOHANG，返回0；失败时返回-1
// wait函数是waitpid函数的简化版本，wait(&status)等价于waitpid(-1, &status, 0)
```

默认情况（options=0）下，`waitpid`挂起调用进程的执行，直到它的**等待集合**中的一个子进程终止。如果等待集合中的一个进程**在刚调用的时刻就已经终止了**，那么`waitpid`函数立即返回。在这两种情况中，`waitpid`返回导致其返回的已终止子进程的PID。此时**已终止的子进程已经被回收**。

* **等待集合**的成员是由参数pid决定的：如果pid>0，那么等待集合只有一个单独的子进程，其进程ID等于pid；如果pid=-1，那么**等待集合就是由父进程所有的子进程组成的**。

* **修改默认行为**：

  1. 默认行为是挂起调用进程，直到有子进程终止。
  2. options=WNOHANG：如果等待集合中的任何子进程都还没有终止，那么就立即返回（返回值为0）。否则同默认行为。
  3. options=WUNTRACED：挂起调用进程的执行，直到等待集合中的一个进程**变成**已终止或被停止。（默认的行为是只返回已终止的子进程）
  4. options=WCONTINUED：挂起被调用进程的执行，直到等待集合中的一个正在运行的进程终止或等待集合中一个被停止的进程收到*SIGCONT*信号重新开始执行。

* **检查已回收子进程的退出状态**

  如果*status*参数是非空的，那么`waitpid`会在其中放上关于导致返回的子进程的状态信息。`wait.h`中定义的部分宏如下：

  1. `WIFEXITED(statussp)`：如果子进程通过调用`exit`或者返回（`return`）正常终止，就返回真。
  2. `WEXITSTATUS(statussp)`：返回一个正常终止的子进程的退出状态。只有`WIFEXITED()`返回真时才会定义这个状态。

* **错误条件**：如果调用进程没有子进程，那么`waitpid`返回-1，且设置`errno`为`ECHILD`；如果`waitpit`函数被一个信号中断，那么也返回-1，并且设置`errno`为`EINTR`。

#### 8.4.4让进程休眠

`sleep`函数将一个进程挂起一段指定的时间：

```C++
#include <unistd.h>
unsigned int sleep(unsigned int secs);
```

如果请求的时间量已经到了，`sleep`返回0，否则返回还剩下的要休眠的秒数。另外有`pause`函数，它让进程休眠，直到其收到一个信号。

#### 8.4.5加载并运行程序

`execve`函数在当前进程的上下文中加载并运行一个新程序。

```C++
#include <unistd.h>
int execve(const char *filename, const char *argv[], const char *envp[]);
```

`execve`函数加载并运行可执行目标文件*filename*，且带参数列表*argv*和环境变量列表*envp*。只有当出现错误，例如找不到*filename*时，`execve`才返回到调用程序。其他情况，`execve`从不返回。*argv*与*envp*变量指向一个以null结尾的指针数组。

> 程序与进程：程序是一堆代码和数据，其可以作为目标文件存在于磁盘上，或者作为段存在于地址空间中；进程是执行中程序的一个具体的示例，程序总是运行在某个进程的上下文中。特别地，`execve`函数在**当前进程**的上下文中加载并运行一个新的程序，它会**覆盖**当前进程的地址空间，而并没有创建一个新的进程。

## 9.虚拟内存

### 9.1地址空间

计算机系统的主存被组织成一个由M个连续的字节大小的单元组成的数组，每字节都有一个唯一的**物理地址**。早期PC使用物理寻址，而现代处理器使用一种称为**虚拟寻址**的寻址形式。CPU会先生成一个虚拟地址，并在CPU芯片上的**内存管理单元（MMU）**进行**地址翻译**转换成适当的**物理地址**。

一个地址空间的大小是由表示最大地址所需要的位数来描述的。例如，一个包含$N=2^n$个地址的虚拟地址空间就叫做一个n位地址空间。

### 9.2虚拟内存用于缓存

虚拟内存（VM）系统将虚拟内存分割为称为**虚拟页（VP）**的大小固定的块。每个虚拟页的大小为$P=2^p$字节。类似地，物理内存也被分割为**物理页（PP）**，大小也为P字节。任意时刻，虚拟页面都有且仅有以下三种状态之一：

1. **未分配的**：VM系统还未分配（或者创建）的页。未分配的块没有任何数据和它们相关联，因此也就不占用任何磁盘空间。
2. **缓存的**：当前已缓存在物理内存中的已分配项。
3. **未缓存的**：当前未缓存在物理内存中的已分配项。

> SRAM表示位于CPU和主存之间的L1、L2和L3高速缓存，DRAM表示虚拟内存系统的缓存，它在主存中缓存虚拟页。DRAM比SRAM的速度要慢大约10倍，而磁盘要比DRAM慢大约100 000倍。

#### 9.2.1页表

页表将虚拟页映射到物理页，其**被存放在物理内存中**。页表实际上就是一个**页表条目**（PTE）构成的数组，虚拟地址空间中的每个页在页表中一个固定偏移量位置有一个PTE。每个PTE由一个**有效位**和一个n位地址字段组成。有效位表明了该**虚拟页当前是否被缓存在DRAM中**。如果设置了有效位，那么地址字段就表示DRAM中相应的物理页的起始位置，这个物理页缓存了该虚拟页。如果没有设置有效位，地址字段存放一个空地址表示这个虚拟页还未被分配，否则这个地址就指向该虚拟页在磁盘上的起始位置。

#### 9.2.2页命中与缺页

地址翻译硬件将虚拟地址作为一个索引来定位PTE，如果设置了有效位，地址翻译硬件就知道该页是缓存在内存中的了，这种情况就被称为**页命中**。反之，**DRAM缓存不命中**就被称为**缺页**。地址翻译软件会触发一个**缺页异常**，该异常调用内核中的缺页异常处理程序，该程序会选择一个**牺牲页**。如果该牺牲页已经被修改了，那么内核就会将它复制回磁盘，并修改**两者**虚拟页对应的页表条目。接下来，异常处理程序返回时会重启导致缺页的指令，该指令会将导致缺页的虚拟地址重新发送到地址翻译硬件，但是现在结果应当是页命中。

> 在磁盘和内存之间传送页面的活动称为**交换**或**页面调动**。当有不命中发生时才换入页面的策略称为**按需页面调度**。当然也有别的方法，比如尝试着预测不命中，在页面实际被引用之前就换入页面。不过，所有现代系统都是用的是按需页面调度的方式。

#### 9.2.3页面调度的性能

程序的局部性原则保证了任意时刻，程序将趋向于在一个较小的活动页面集合上工作，这个集合叫做**工作集**或是**常驻集合**。在初始开销，也就是将工作集页面调度到内存中后，接下来对这个工作集的引用将导致命中，而不会产生额外的磁盘流量。

只要程序有好的时间局部性，虚拟内存系统就能工作得相当好。但是，如果工作集的大小超过了物理内存的大小，程序就会产生一种被称为**抖动**的状态，此时页面将不断地换进换出，大幅度降低程序性能。

#### 9.2.4虚拟内存用于内存管理和内存保护

按需页面调度和独立的虚拟地址空间的结合，对系统中内存的使用和管理造成了深远的影响。特别地，VM简化了**链接和加载**、**代码和数据共享**，以及**应用程序的内存分配**。

此外，提供独立的地址空间使得区分不同进程的私有内存变得容易，每次CPU生成一个地址，地址翻译硬件都会读一个PTE，因此在PTE上添加一些额外的访问位就可以控制对一个虚拟页面内容的访问。如果某一条指令违反了这些许可条件，那么CPU就会触发一个**一般保护故障**，将控制传递给内核中的异常处理程序。Linux Shell会将这种异常报告为**段错误**。

> 注意：访问权限检查是**地址翻译**过程的一部分。

### 9.3地址翻译

#### 9.3.1地址翻译过程

形式上来说，地址翻译就是一个N元素的虚拟地址空间中的元素和一个M元素的物理地址空间中元素之间的映射。CPU中的一个控制寄存器**页表基址寄存器**会指向当前页表。n位的虚拟地址包含两个部分：一个p位的**虚拟页面偏移**（VPO）和一个（n-p）位的**虚拟页号**（VPN）。MMU就通过VPN来选择适当的PTE。然后，将页表条目中**物理页号**（VPN）和虚拟地址的VPO串联起来，就得到相应的物理地址。注意，由于物理和虚拟页面都是P字节，所以**物理页面偏移**（PPO）和VPO是**相同的**。

页面命中时，CPU执行的步骤如下：

1. 处理器生成一个虚拟地址，并把它传送给MMU
2. MMU生成PTE地址（PTEA），并从**高速缓存/主存**请求得到它
3. 高速缓存/主存向MMU返回PTE
4. MMU构造物理地址，并把它传送给高速缓存/主存（注意在这里，缓存也可能不命中，说明需要的内存块不在缓存中）
5. 高速缓存/主存返回所请求的数据字给处理器

处理缺页时，CPU执行的步骤如下（前3步与上相同）：

4. PTE中有效位是零，这时MMU触发了一次异常，传递CPU的操作到操作系统内核中的缺页处理程序

   > 注意，无论这时PPN存储的是什么值，都是**没有任何意义的**。

5. 缺页处理程序确定出物理内存中的牺牲页。如果这个页面已经被修改了，则**把它换出到磁盘**

6. 缺页处理程序页面调入新的页面，并更新内存中的PTE

7. 缺页处理程序返回到原来的进程，再次执行导致缺页的指令。此时会命中。

#### 9.3.2使用TLB加速翻译

如9.3.1节所述，每次CPU产生一个虚拟地址，MMU就必须查阅一个PTE，以便将虚拟地址翻译为物理地址。在最糟糕的情况下，这会要求从内存多取一次数据，代价是**几十到几百个周期**。因此，许多系统在MMU中包括了一个关于PTE的小的缓存，称为**翻译后备缓冲器**（Translation Lookaside Buffer, **TLB**）。

TLB是一个小的、虚拟寻址的缓存，其中每一行都保存着一个由单个PTE组成的块，且被分成了若干组。**用于组选择和行匹配的索引和标记字段是从虚拟地址的虚拟页号中提取出来的**。如果TLB有$T=2^t$个组，那么**TLB索引**（TLBI）是由VPN的t个最低位组成的，而**TLB标记**（TLBT）是由VPN中剩余的位组成的。即$\underset{VPN}{\underline{_{n-1}(TLBT)_{p+t}\space{_{p+t-1}(TLBI)_{p}}}}\space{_{p-1}(VPO)_0}$。

TLB命中时的步骤如下：

1. CPU产生一个虚拟地址
2. MMU从TLB中提取出相应的PTE
3. MMU将这个虚拟地址翻译成一个物理地址，并且将它发送到高速缓存/主存
4. 高速缓存/主存将所请求的数据字返回给CPU

而当TLB不命中时，MMU必须从高速缓存/主存中取出相应的PTE，并且，**新取出的PTE会存放在TLB中，可能会覆盖一个已经存在的条目**。

#### 9.3.3多级页表

假设我们有一个32位的地址空间、4KB的页面以及4字节的PTE，那么即使应用所引用的只是虚拟地址空间中很小的一部分，也总是需要$2^{32}\div(4\times2^{10})\times4=2^{20}=4MB$的页表驻留在内存中。用来压缩页表的常用方法是**使用层次结构的页表**。例如，我们让一级页表中的每个PTE负责映射虚拟地址空间中一个4MB的片，也就是其指向一个二级页表的基址，二级页表中的每个PTE指向一个4KB的页面。如果某一片中的每个页面都未被分配，那么对应的一级页表中的PTE就为空，**相应的二级页表就根本不会存在**。因此，只有一级页表才需要总是在主存中：这大大减少了主存的压力。并且，实际上，带多级页表的地址翻译并不比单极页表慢很多。

### 9.4Linux虚拟内存系统

Linux将虚拟内存组织成一些区域（也叫做段）的集合。一个区域就是已经存在着的（已分配的）虚拟内存的**连续片**。区域的概念**允许虚拟地址空间有间隙**。Linux内核为系统中的每个进程维护一个单独的**任务结构**，其中的元素包含或者指向内核运行该进程所需要的所有信息（例如PID，指向用户栈的指针、可执行目标文件名字，以及程序计数器等），这些任务结构会被组成成链表。如下所示：（实际上，Linux在链表中构建了一棵树，并在这棵树上进行查找。）

| 字段     | 功能                                                         |
| -------- | ------------------------------------------------------------ |
| vm_start | 指向这个区域的起始处                                         |
| vm_end   | 指向这个区域的结束处                                         |
| vm_prot  | 描述这个区域内包含的所有页的读写许可权限                     |
| vm_flags | 描述这个区域内的页面是与其他进程共享的，还是这个进程私有的（以及一些其他信息） |
| vm_next  | 指向链表中下一个区域结构                                     |

### 9.5内存映射

Linux通过将一个虚拟内存区域与一个磁盘上的对象关联起来，以初始化这个虚拟内存区域的内容，这个过程称为**内存映射**。虚拟内存区域可以映射到两种类型的对象中的一种：

1. **Linux文件系统中的普通文件**：一个区域可以映射到一个普通磁盘文件的连续部分，例如一个可执行目标文件。**文件区**也被分成页大小的片，每一片包含一个虚拟页面的初始内容。由于按需进行页面调度，所以这些虚拟页面并没有实际交换进入物理内存，直到CPU第一次引用到页面。如果区域比文件要大，那么就用零来填充余下部分。
2. **匿名文件**：一个区域也可以映射到一个匿名文件，匿名文件是由内核创建的，包含的**全是二进制零**。CPU第一次引用这样一个区域内的虚拟页面时，内核就在物理内存中找到一个合适的牺牲页面，用二进制零覆盖牺牲页面并更新页表。注意这种情况下在磁盘和内存之间并没有实际的数据传送，因此，映射到匿名文件区域中的页面有时也叫做**请求二进制零的页面**。

无论哪种情况下，一旦一个虚拟页面被初始化了，它就在一个由内核维护的专门的**交换文件**之间换来换去。交换文件也叫做交换空间或者交换区域。

映射到共享对象的虚拟内存区域叫做**共享区域**，类似地也有私有区域。私有对象采用一种叫做**写时复制**的巧妙技术被映射到虚拟内存中。只要没有进程试图写它自己的私有区域，多个进程就可以共享物理内存中对象的一个单独副本；然而，只要有一个进程试图写私有区域内的某个页面，那么这个写操作就会触发一个**保护故障**。故障处理程序会在物理内存中创建这个页面的一个新副本，更新页表条目指向这个新副本，然后恢复这个页面的可写权限。**通过延迟私有对象中的副本直到最后可能的时刻**，写时复制最充分地使用了稀有的物理内存。

> * 再看`fork`函数：当`fork()`被当前进程调用时，内核为新进程创建各种数据结构，并分配给它一个唯一的PID。同时，它将两个进程中的每个页面都标记为只读，并将两个进程中的每个区域结构都标记未私有的**写时复制**。
> * 再看`execve`函数：`execve()`会首先删除当前进程虚拟地址的用户部分中已存在的**区域结构**，并为新程序的代码、数据、bss和栈区域创建新的区域结构，所有这些新的区域都是**私有的、写时复制的**。其中bss区域是请求二进制零，映射到匿名文件，栈和堆区域也是如此。同时，如果新程序与共享对象链接，那么这些对象都是动态链接到这个程序的，然后再映射到**用户虚拟地址空间的共享区域内**。最后，`execve()`设置程序计数器使其指向代码区域的入口点即可。

## 10.系统级I/O

输入/输出（I/O）是在主存和外部设备之间复制数据的过程。输入操作是从I/O设备复制数据到主存，而输出操作是从主存复制数据到I/O设备。

Linux中，所有的I/O设备（例如网络、磁盘和终端）都被模型化为**文件**，而所有的输入和输出都被当作对相应文件的**读和写**来执行。通过这种优雅的方式，Linux内核可以引出一个简单、低级的应用接口，称为Unix I/O：

1. **打开文件**：内核会返回一个小的非负整数，叫做**描述符**，它在后续对此文件的所有操作中标识这个文件。

   > Linux Shell创建的每个进程开始时都有三个打开的文件：**标准输入**（描述符为0），**标准输出**（描述符为1）和**标准错误**（描述符为2）。

2. **改变当前的文件位置**：对每个打开的文件，内核保持着一个**文件位置k**，初始化为0。这个文件位置是指从文件开头起始的**字节偏移量**，应用程序能够通过执行`seek`操作显示地设置文件的当前位置。

3. **读写文件**：一个读操作就是从文件复制n>0个字节到内存，从当前文件位置k开始，将k增加到k+n。若文件大小给定为m字节，当$k\geq m$时会触发“**end-of-file(EOF)**”。（当然在文件结尾并没有明确的“EOF”符号）。类似地，写操作就是从内存复制n>0个字节到一个文件，然后更新k。

4. **关闭文件**：内核会释放文件打开时创建的数据结构，并将这个描述符恢复到可用的**描述符池**中。无论一个进程因为何种原因终止时，内核都会关闭所有打开的文件并释放它们占用的内存资源。

### 10.1文件与目录

* **普通文件**：包含任意数据。应用程序常常要区分**文本文件**和**二进制文件**。前者是只含有ASCII或Unicode字符的普通文件。二进制文件则是所有其他的文件。值得注意的是，对内核来说，**二者没有区别**。
* **目录**：包含一组**链接**的文件。其中每个连接都将一个**文件名**映射到一个**文件**，这个文件也可能是另一个目录。
* **套接字**：用来与另一个进程进行跨网络通信的文件。

其他文件类型还包括**命名通道**、**符号链接**以及**字符和块设备**等。Linux内核将所有文件都组织成一个**目录层次结构**，由名为“**/**”的根目录确定，系统中每个文件都是根目录直接或间接的后代。

```C++
int open(char *filename, int flags, mode_t mode);
int close(int fd);
```

进程是通过调用`open`函数来打开一个已存在的文件或者创建一个新文件。其中，`flag`参数指明了进程打算如何访问这个文件：**O_RDONLY**：只读；**O_WRONLY**：只写；**O_RDWR**：可读可写，等。`mode`参数指定了新文件的访问权限位，包括：**S_IRUSR**：使用者能够读这个文件；**S_IWUSR**：使用者能够写这个文件；**S_IXUSR**：使用者能够执行这个文件，等。若成功，`open`函数返回新文件的描述符，其总是在进程中当前没有打开的最小描述符。

```C++
ssize_t read(int fd, void *buf, size_t n); // ssize_t is defined as long so it has a sign
ssize_t write(int fd, const void *buf, size_t n);
```

`read()`函数从描述符位fd的当前文件位置复制**至多**n个字节到内存位置buf。返回值为-1时表示一个错误，返回值为0表示遇到了**EOF**，否则，返回值表示的是实际传送的字节数量。`write()`函数从内存位置buf复制**至多**n个字节到描述符fd的当前文件位置。

> 某些情况下，`read`和`write`传送的字节比应用程序要求的要少。这些**不足值**并不一定表示有错误。可能的原因有：
>
> 1. 读的时候遇到**EOF**。
> 2. 从终端读文本行。这时每个`read`函数将每次只传送一个文本行。
> 3. 读和写网络套接字。

```C++
int stat(const char *filename, struct stat *buf);
int fstat(int fd, struct stat *buf);
```

应用程序能够通过调用`stat`和`fstat`函数，检索到关于文件的信息，也称为文件的**元数据**。`stat`函数以一个文件名作为输入，并返回一个`stat`数据结构，其中的各个成员描述了这个文件。`fstat`函数作用类似，只不过其是以文件描述符而不是文件名作为输入。

```C++
DIR *opendir(const char *name);
struct dirent *readdir(DIR *dirp);
int close(DIR *dirp);
```

应用程序可以用`readdir`系列函数来读取目录内容。`opendir`返回指向**目录流**的指针（这里即指目录项的列表），若出错则返回NULL。而每次对`readdir`的调用返回的都是指向流*dirp*中**下一个目录项的指针**，或者，如果没有更多目录项会返回NULL，并设置errno。`closedir`函数关闭流并释放其所有的资源。

### 10.2共享文件

Linux内核用三个相关的数据结构来表示打开的文件：

1. **描述符表**：每个进程都有它独立的描述符表，它的表项是由进程打开的文件描述符来索引的。每个打开的描述符表项指向**文件表**中的一个表项。
2. **文件表**：打开文件的集合是由一张文件表来表示的，**所有的进程共享这张表**。每个文件表的表项组成包括**当前的文件位置**、**引用计数**，以及一个**指向v-node表中对应表项的指针**。**关闭一个描述符会减少相应的文件表表项中的引用计数**。==内核不会删除这个表项，直到它的引用计数为零。==
3. **v-node表**：同文件表一样，所有的进程共享这张v-node表。每个表项包含*stat*结构中的大多数信息。

特别地，多个描述符可以通过不同的文件表表项来引用同一个文件。例如当以同一个*filename*调用`open`函数两次时，就会发生这种情况。对于父子进程，二者共享相同的打开文件表集合。注意，子进程这时继承父进程**已经打开了的**文件时，并不会另新建表项，而是将该文件原表项的**引用计数直接+1**。原因在于，两个进程中对于该文件的**描述符**相同，自然也就对应同一个文件表表项。因此，在内核删除相应文件表表项之前，父子进程必须都关闭了它们的描述符。

### 10.3I/O重定向

```bash
linux> ls > foo.txt
```

这里的“**>**”就是一个**重定向操作符**（“>”表示覆盖，而“>>”表示追加），这种操作符允许用户将磁盘文件和标准输入输出联系起来。I/O重定向的工作基于函数`dup2`：

```C++
int dup2(int oldfid, int newfd);
```

`dup2()`函数复制**描述符表项**oldfd到**描述符表项**newfd，覆盖描述符表表项newfd以前的内容。如果newfd已经打开了，那么`dup2`会在复制oldfd前关闭newfd。

### 10.4标准I/O

C语言定义了一组高级输入输出函数，称为**标准I/O库**，为程序员提供了Unix I/O的较高级别的替代。这个库（libc）提供了打开和关闭文件的函数（`fopen`和`fclose`），读和写字节的函数（`fread`和`fwrite`），读和写字符串的函数（`fgets`和`fgets`），以及复杂的格式化的I/O函数（`scanf`和`printf`）。标准I/O库实际上是将一个打开的文件模型化为一个流。

> **流缓冲区**的目的是使开销较高的Linux I/O系统调用的数量尽可能少。